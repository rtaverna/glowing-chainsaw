{"version":3,"file":"react-photo-grid.cjs.production.min.js","sources":["../src/ReactPhotoGrid.tsx"],"sourcesContent":["import * as React from \"react\";\n\n// TODO - element resize event is not working\nvar imageElements: Array<HTMLImageElement> = [];\n\nfunction imageLoadCallback(\n  id: string,\n  callback: (id: string, width: number, height: number) => void\n) {\n  return function (this: HTMLImageElement) {\n    callback(id, this.naturalWidth, this.naturalHeight);\n  };\n}\n\nfunction getImageDimensions(\n  src: string,\n  id: string,\n  cb: (id: string, width: number, height: number) => void\n) {\n  var img = new Image();\n  img.id = id;\n  imageElements.push(img);\n  img.addEventListener(\"load\", imageLoadCallback(id, cb));\n\n  img.src = src;\n}\n\nfunction isString(str: unknown) {\n  return typeof str === \"string\";\n}\n\nfunction first<T>(arr: Array<T>): T {\n  return arr[0];\n}\n\nfunction without<T>(arr: Array<T>, exclude: T): Array<T> {\n  return arr.filter((item) => item !== exclude);\n}\n\nfunction findIndex<T>(arr: Array<T>, pred: (val: T) => boolean): number {\n  return arr.reduce((acc, val, index) => {\n    if (acc >= 0) {\n      return acc;\n    }\n\n    return pred(val) ? index : acc;\n  }, -1);\n}\n\nfunction all<T>(arr: Array<T>, pred: (val: T) => boolean): boolean {\n  return arr.reduce((acc: boolean, item: T) => {\n    return pred(item) && acc;\n  }, true);\n}\n\nfunction max<T>(arr: Array<T>, iteratee: (arg0: T) => number) {\n  return arr.reduce((acc, item) => {\n    if (iteratee(item) > iteratee(acc)) {\n      return item;\n    } else {\n      return acc;\n    }\n  }, arr[0]);\n}\n\ninterface ImageData {\n  id: string;\n  src: string;\n}\n\ntype StateImageData = ImageData & {\n  width: number;\n  height: number;\n};\n\ninterface Props {\n  data: Array<string> | Array<ImageData>;\n  onImageClick: (image: string) => void;\n  gridSize?: string;\n  containerWidth?: number;\n}\n\ninterface State {\n  ladyLuck: number;\n  containerWidth: number;\n  containerHeight: number;\n  imagesToShow: Array<StateImageData>;\n}\n\nclass ReactPhotoGrid extends React.Component<Props, State> {\n  private containerRef = React.createRef<HTMLDivElement>();\n\n  constructor(props: Props) {\n    super(props);\n\n    const defaultContainerWidth = 500;\n    const defaultContainerHeight = 500;\n\n    let containerWidth = defaultContainerWidth;\n    let containerHeight = defaultContainerHeight;\n\n    if (this.props.gridSize) {\n      var container = this.props.gridSize.split(\"x\");\n      containerWidth = parseInt(container[0], 10) || defaultContainerWidth;\n      containerHeight = parseInt(container[1], 10) || defaultContainerHeight;\n    }\n\n    const imageData =\n      this.props.data.length <= 4\n        ? this.props.data\n        : this.props.data.slice(0, 4);\n    let imagesToShow;\n\n    // take care of variations in property data\n    // if someone just passes an array of path strings\n    if (imageData[0] && isString(imageData[0])) {\n      imagesToShow = (imageData as Array<string>).map(function (\n        imagePath: string\n      ) {\n        return {\n          id: `${Math.random() * 1000}`,\n          src: imagePath,\n          width: 0,\n          height: 0,\n        };\n      });\n    } else {\n      imagesToShow = (imageData as Array<ImageData>).map(function (\n        image: ImageData\n      ) {\n        return {\n          id: image.id || `${Math.random() * 1000}`,\n          src: image.src, // in case someone supplies a src property instead of path\n          ...image,\n          width: 0,\n          height: 0,\n        };\n      });\n    }\n\n    var state = {\n      ladyLuck: Math.floor(Math.random() * 2),\n      containerWidth: containerWidth,\n      containerHeight: containerHeight,\n      imagesToShow,\n    };\n\n    if (this.props.containerWidth) {\n      state.containerWidth = this.props.containerWidth;\n    }\n\n    this.state = state;\n  }\n\n  componentWillUnmount() {\n    imageElements.forEach((imageElement) => {\n      imageElement.removeEventListener(\n        \"load\",\n        imageLoadCallback(imageElement.id, this.recalculateGrid)\n      );\n    });\n  }\n\n  componentDidMount() {\n    this.state.imagesToShow.forEach((image: StateImageData) => {\n      getImageDimensions(image.src, image.id, this.recalculateGrid);\n    }, this);\n\n    // only set it to parents width/height if no gridsize is provided\n    if (\n      !this.props.gridSize &&\n      this.containerRef &&\n      this.containerRef.current\n    ) {\n      this.setState({\n        containerWidth: this.containerRef.current.offsetWidth,\n        containerHeight: this.containerRef.current.offsetWidth,\n      });\n    }\n\n    // $(ReactDOM.findDOMNode(this)..resize(this.onResize);\n    // elementResizeEvent(ReactDOM.findDOMNode(this). this.onResize);\n  }\n\n  // Throttle updates to 60 FPS.\n  onResize = () => {\n    if (this.containerRef && this.containerRef.current) {\n      this.setState({\n        containerWidth: this.containerRef.current.offsetWidth,\n        containerHeight: this.containerRef.current.offsetWidth,\n      });\n    }\n  };\n\n  handleImageClick = (imageSrc: string) => {\n    this.props.onImageClick && this.props.onImageClick(imageSrc);\n  };\n\n  recalculateGrid = (id: string, width: number, height: number) => {\n    var _imagesToShow = [...this.state.imagesToShow];\n\n    var imageIndex = findIndex(_imagesToShow, (image) => image.id === id);\n    _imagesToShow[imageIndex].width = width;\n    _imagesToShow[imageIndex].height = height;\n    var indexForMaxDimensionImage = 0;\n    var container = {\n      width: this.state.containerWidth,\n      height: this.state.containerHeight,\n    };\n\n    var contenders = [\"Width\", \"Height\"];\n    var winner = contenders[this.state.ladyLuck].toLowerCase() as\n      | \"width\"\n      | \"height\";\n    var loser = first(\n      without(contenders, contenders[this.state.ladyLuck])\n    ).toLowerCase() as \"width\" | \"height\";\n\n    // if all the images have width and height, we can rotate the array around the image with max height,\n    // so that the first image has the max height and can be displayed properly on the left side\n    if (\n      all(_imagesToShow, (image: StateImageData) => {\n        return !!(image.width && image.height);\n      })\n    ) {\n      // TODO - the logic should not only look the the image with max height but with height >= containerHeight and max(height/width ratio)\n\n      var maxDimensionImage = max(_imagesToShow, (image) => image[winner]);\n\n      indexForMaxDimensionImage = findIndex(\n        _imagesToShow,\n        (image) => image.id === maxDimensionImage.id\n      );\n\n      if (\n        _imagesToShow[indexForMaxDimensionImage][winner] < container[winner]\n      ) {\n        container[winner] = _imagesToShow[indexForMaxDimensionImage][winner];\n        container[loser] = container[winner];\n      }\n\n      var indexForBestMaxImage = _imagesToShow.reduce(function (\n        result,\n        image,\n        index\n      ) {\n        if (\n          image[winner] >= container[winner] &&\n          image[winner] / image[loser] >\n            _imagesToShow[result][winner] / _imagesToShow[result][loser]\n        ) {\n          return index;\n        }\n        return result;\n      },\n      0);\n\n      _imagesToShow.push.apply(\n        _imagesToShow,\n        _imagesToShow.splice(0, indexForBestMaxImage)\n      );\n      this.setState({\n        imagesToShow: _imagesToShow,\n        containerHeight: container.height,\n        containerWidth: container.width,\n      });\n    }\n  };\n\n  getComponentStyles = (images: Array<StateImageData>) => {\n    var numberOfImages = images.length;\n\n    var marginSetters = [\"Bottom\", \"Right\"];\n    var contenders = [\"Width\", \"Height\"];\n    var winner = contenders[this.state.ladyLuck] as \"Width\" | \"Height\";\n    var loser = first(without(contenders, winner));\n    var marginWinner = marginSetters[this.state.ladyLuck];\n    var marginLoser = first(without(marginSetters, marginWinner));\n\n    var smallestDimensionRaw = Math.floor(\n      this.state[`container${winner}` as \"containerWidth\"] /\n        (numberOfImages - 1)\n    );\n    var margin = 2;\n    var smallImageDimension = smallestDimensionRaw - margin;\n    var styles: Array<any> = [];\n    var commonStyle = {\n      display: \"inline-block\",\n      position: \"relative\",\n      overflow: \"hidden\",\n      float: \"left\",\n      verticalAlign: \"top\",\n      cursor: \"pointer\",\n    };\n\n    switch (numberOfImages) {\n      case 0:\n        break;\n      case 1:\n        // set some big numbers in case width and height not provided\n        if (!images[0].width) images[0].width = 1000000;\n        if (!images[0].height) images[0].height = 1000000;\n\n        if (images[0].width > images[0].height) {\n          styles = [\n            {\n              width:\n                Math.min(this.state.containerWidth, images[0].width) - margin,\n              height:\n                (Math.min(this.state.containerWidth, images[0].width) *\n                  images[0].height) /\n                  images[0].width -\n                margin,\n              margin: margin,\n            },\n          ];\n        } else {\n          styles = [\n            {\n              width:\n                (Math.min(this.state.containerHeight, images[0].height) *\n                  images[0].width) /\n                  images[0].height -\n                margin,\n              height:\n                Math.min(this.state.containerHeight, images[0].height) - margin,\n              margin: margin,\n            },\n          ];\n        }\n        break;\n      case 2:\n        styles[0] = styles[1] = {};\n\n        styles[0][winner.toLowerCase() as \"width\" | \"height\"] = styles[1][\n          winner.toLowerCase() as \"width\" | \"height\"\n        ] =\n          this.state[\n            `container${winner}` as \"containerWidth\" | \"containerHeight\"\n          ] - margin;\n        styles[0][loser.toLowerCase()] = styles[1][loser.toLowerCase()] =\n          Math.min(smallImageDimension / 2) - margin;\n        styles[0][\"margin\" + marginWinner] = margin;\n        break;\n      default:\n        styles[0] = {};\n        styles[0][winner.toLowerCase()] = this.state[\n          `container${winner}` as \"containerWidth\" | \"containerHeight\"\n        ];\n        styles[0][loser.toLowerCase()] =\n          smallImageDimension * (numberOfImages - 2);\n        styles[0][\"margin\" + marginWinner] = margin;\n        var styleForSmallerImages: any = {\n          width: smallImageDimension,\n          height: smallImageDimension,\n        };\n        styleForSmallerImages[\"margin\" + marginLoser] = margin;\n\n        for (var i = 1; i < numberOfImages && i < 4; i++) {\n          // cloning is important here because otherwise changing the dimension of last image changes it for everyone\n          styles.push({ ...styleForSmallerImages });\n        }\n\n        // adjust the width/height of the last image in case of round off errors in division\n        styles[numberOfImages - 1][winner.toLowerCase()] +=\n          styles[0][winner.toLowerCase()] -\n          smallImageDimension * (numberOfImages - 1) -\n          margin * (numberOfImages - 2);\n        styles[numberOfImages - 1][\"margin\" + marginLoser] = 0;\n    }\n\n    return styles.map(function (style) {\n      return {\n        ...commonStyle,\n        ...style,\n      };\n    });\n  };\n\n  render() {\n    var componentStyles = this.getComponentStyles(this.state.imagesToShow);\n\n    var images = this.state.imagesToShow.map((image, index) => {\n      var componentStyle = componentStyles[index];\n\n      // max width and height has to be dynamic depending on this image's dimensions\n      var imageStyle;\n\n      if (\n        image.width &&\n        image.height &&\n        componentStyle.width &&\n        componentStyle.height\n      ) {\n        if (\n          image.width <= componentStyle.width ||\n          image.height <= componentStyle.height\n        ) {\n          // do nothing\n        } else if (\n          image.width / componentStyle.width <\n          image.height / componentStyle.height\n        ) {\n          imageStyle = {\n            maxWidth: componentStyle.width,\n          };\n        } else {\n          imageStyle = {\n            maxHeight: componentStyle.height,\n          };\n        }\n      }\n\n      return (\n        <div key={\"image_\" + index} style={componentStyle}>\n          <img\n            style={imageStyle}\n            src={image.src}\n            onClick={() => this.handleImageClick(image.src)}\n          />\n        </div>\n      );\n    }, this);\n\n    var containerStyle = {\n      width: this.state.containerWidth,\n      height: this.state.containerWidth,\n      backgroundColor: \"white\",\n    };\n    // the outer div is needed so that container width can be recalculated based on the parent container width (which the outer div inherits\n    // the div inside the outer div is assigned a width in the first render itself. so that doesn't work out while trying to reset container width\n    return (\n      <div>\n        <div style={containerStyle}>\n          {images}\n          <div style={{ clear: \"both\" }} />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default ReactPhotoGrid;\n"],"names":["imageElements","imageLoadCallback","id","callback","this","naturalWidth","naturalHeight","first","arr","without","exclude","filter","item","findIndex","pred","reduce","acc","val","index","props","React","_this","containerRef","current","setState","containerWidth","offsetWidth","containerHeight","imageSrc","onImageClick","width","height","_imagesToShow","state","imagesToShow","imageIndex","image","indexForMaxDimensionImage","container","contenders","winner","ladyLuck","toLowerCase","loser","maxDimensionImage","iteratee","max","indexForBestMaxImage","result","push","apply","splice","images","numberOfImages","length","marginSetters","marginWinner","marginLoser","smallImageDimension","Math","floor","styles","commonStyle","display","position","overflow","float","verticalAlign","cursor","min","margin","styleForSmallerImages","i","map","style","gridSize","split","parseInt","imageData","data","slice","imagePath","random","src","componentWillUnmount","forEach","imageElement","removeEventListener","_this2","recalculateGrid","componentDidMount","cb","img","_this3","Image","addEventListener","render","componentStyles","getComponentStyles","imageStyle","componentStyle","maxWidth","maxHeight","key","onClick","_this4","handleImageClick","backgroundColor","clear"],"mappings":"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"}