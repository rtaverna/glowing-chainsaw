{"ast":null,"code":"import { createElement, createRef, Component } from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar imageElements = [];\n\nfunction imageLoadCallback(id, callback) {\n  return function () {\n    callback(id, this.naturalWidth, this.naturalHeight);\n  };\n}\n\nfunction getImageDimensions(src, id, cb) {\n  var img = new Image();\n  img.id = id;\n  imageElements.push(img);\n  img.addEventListener(\"load\", imageLoadCallback(id, cb));\n  img.src = src;\n}\n\nfunction isString(str) {\n  return typeof str === \"string\";\n}\n\nfunction first(arr) {\n  return arr[0];\n}\n\nfunction without(arr, exclude) {\n  return arr.filter(function (item) {\n    return item !== exclude;\n  });\n}\n\nfunction findIndex(arr, pred) {\n  return arr.reduce(function (acc, val, index) {\n    if (acc >= 0) {\n      return acc;\n    }\n\n    return pred(val) ? index : acc;\n  }, -1);\n}\n\nfunction all(arr, pred) {\n  return arr.reduce(function (acc, item) {\n    return pred(item) && acc;\n  }, true);\n}\n\nfunction max(arr, iteratee) {\n  return arr.reduce(function (acc, item) {\n    if (iteratee(item) > iteratee(acc)) {\n      return item;\n    } else {\n      return acc;\n    }\n  }, arr[0]);\n}\n\nvar ReactPhotoGrid = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ReactPhotoGrid, _React$Component);\n\n  function ReactPhotoGrid(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.containerRef = createRef(); // Throttle updates to 60 FPS.\n\n    _this.onResize = function () {\n      if (_this.containerRef && _this.containerRef.current) {\n        _this.setState({\n          containerWidth: _this.containerRef.current.offsetWidth,\n          containerHeight: _this.containerRef.current.offsetWidth\n        });\n      }\n    };\n\n    _this.handleImageClick = function (imageSrc) {\n      _this.props.onImageClick && _this.props.onImageClick(imageSrc);\n    };\n\n    _this.recalculateGrid = function (id, width, height) {\n      var _imagesToShow = [].concat(_this.state.imagesToShow);\n\n      var imageIndex = findIndex(_imagesToShow, function (image) {\n        return image.id === id;\n      });\n      _imagesToShow[imageIndex].width = width;\n      _imagesToShow[imageIndex].height = height;\n      var indexForMaxDimensionImage = 0;\n      var container = {\n        width: _this.state.containerWidth,\n        height: _this.state.containerHeight\n      };\n      var contenders = [\"Width\", \"Height\"];\n\n      var winner = contenders[_this.state.ladyLuck].toLowerCase();\n\n      var loser = first(without(contenders, contenders[_this.state.ladyLuck])).toLowerCase(); // if all the images have width and height, we can rotate the array around the image with max height,\n      // so that the first image has the max height and can be displayed properly on the left side\n\n      if (all(_imagesToShow, function (image) {\n        return !!(image.width && image.height);\n      })) {\n        // TODO - the logic should not only look the the image with max height but with height >= containerHeight and max(height/width ratio)\n        var maxDimensionImage = max(_imagesToShow, function (image) {\n          return image[winner];\n        });\n        indexForMaxDimensionImage = findIndex(_imagesToShow, function (image) {\n          return image.id === maxDimensionImage.id;\n        });\n\n        if (_imagesToShow[indexForMaxDimensionImage][winner] < container[winner]) {\n          container[winner] = _imagesToShow[indexForMaxDimensionImage][winner];\n          container[loser] = container[winner];\n        }\n\n        var indexForBestMaxImage = _imagesToShow.reduce(function (result, image, index) {\n          if (image[winner] >= container[winner] && image[winner] / image[loser] > _imagesToShow[result][winner] / _imagesToShow[result][loser]) {\n            return index;\n          }\n\n          return result;\n        }, 0);\n\n        _imagesToShow.push.apply(_imagesToShow, _imagesToShow.splice(0, indexForBestMaxImage));\n\n        _this.setState({\n          imagesToShow: _imagesToShow,\n          containerHeight: container.height,\n          containerWidth: container.width\n        });\n      }\n    };\n\n    _this.getComponentStyles = function (images) {\n      var numberOfImages = images.length;\n      var marginSetters = [\"Bottom\", \"Right\"];\n      var contenders = [\"Width\", \"Height\"];\n      var winner = contenders[_this.state.ladyLuck];\n      var loser = first(without(contenders, winner));\n      var marginWinner = marginSetters[_this.state.ladyLuck];\n      var marginLoser = first(without(marginSetters, marginWinner));\n      var smallestDimensionRaw = Math.floor(_this.state[\"container\" + winner] / (numberOfImages - 1));\n      var margin = 2;\n      var smallImageDimension = smallestDimensionRaw - margin;\n      var styles = [];\n      var commonStyle = {\n        display: \"inline-block\",\n        position: \"relative\",\n        overflow: \"hidden\",\n        float: \"left\",\n        verticalAlign: \"top\",\n        cursor: \"pointer\"\n      };\n\n      switch (numberOfImages) {\n        case 0:\n          break;\n\n        case 1:\n          // set some big numbers in case width and height not provided\n          if (!images[0].width) images[0].width = 1000000;\n          if (!images[0].height) images[0].height = 1000000;\n\n          if (images[0].width > images[0].height) {\n            styles = [{\n              width: Math.min(_this.state.containerWidth, images[0].width) - margin,\n              height: Math.min(_this.state.containerWidth, images[0].width) * images[0].height / images[0].width - margin,\n              margin: margin\n            }];\n          } else {\n            styles = [{\n              width: Math.min(_this.state.containerHeight, images[0].height) * images[0].width / images[0].height - margin,\n              height: Math.min(_this.state.containerHeight, images[0].height) - margin,\n              margin: margin\n            }];\n          }\n\n          break;\n\n        case 2:\n          styles[0] = styles[1] = {};\n          styles[0][winner.toLowerCase()] = styles[1][winner.toLowerCase()] = _this.state[\"container\" + winner] - margin;\n          styles[0][loser.toLowerCase()] = styles[1][loser.toLowerCase()] = Math.min(smallImageDimension / 2) - margin;\n          styles[0][\"margin\" + marginWinner] = margin;\n          break;\n\n        default:\n          styles[0] = {};\n          styles[0][winner.toLowerCase()] = _this.state[\"container\" + winner];\n          styles[0][loser.toLowerCase()] = smallImageDimension * (numberOfImages - 2);\n          styles[0][\"margin\" + marginWinner] = margin;\n          var styleForSmallerImages = {\n            width: smallImageDimension,\n            height: smallImageDimension\n          };\n          styleForSmallerImages[\"margin\" + marginLoser] = margin;\n\n          for (var i = 1; i < numberOfImages && i < 4; i++) {\n            // cloning is important here because otherwise changing the dimension of last image changes it for everyone\n            styles.push(_extends({}, styleForSmallerImages));\n          } // adjust the width/height of the last image in case of round off errors in division\n\n\n          styles[numberOfImages - 1][winner.toLowerCase()] += styles[0][winner.toLowerCase()] - smallImageDimension * (numberOfImages - 1) - margin * (numberOfImages - 2);\n          styles[numberOfImages - 1][\"margin\" + marginLoser] = 0;\n      }\n\n      return styles.map(function (style) {\n        return _extends(_extends({}, commonStyle), style);\n      });\n    };\n\n    var defaultContainerWidth = 500;\n    var defaultContainerHeight = 500;\n    var containerWidth = defaultContainerWidth;\n    var containerHeight = defaultContainerHeight;\n\n    if (_this.props.gridSize) {\n      var container = _this.props.gridSize.split(\"x\");\n\n      containerWidth = parseInt(container[0], 10) || defaultContainerWidth;\n      containerHeight = parseInt(container[1], 10) || defaultContainerHeight;\n    }\n\n    var imageData = _this.props.data.length <= 4 ? _this.props.data : _this.props.data.slice(0, 4);\n    var imagesToShow; // take care of variations in property data\n    // if someone just passes an array of path strings\n\n    if (imageData[0] && isString(imageData[0])) {\n      imagesToShow = imageData.map(function (imagePath) {\n        return {\n          id: \"\" + Math.random() * 1000,\n          src: imagePath,\n          width: 0,\n          height: 0\n        };\n      });\n    } else {\n      imagesToShow = imageData.map(function (image) {\n        return _extends(_extends({\n          id: image.id || \"\" + Math.random() * 1000,\n          src: image.src\n        }, image), {}, {\n          width: 0,\n          height: 0\n        });\n      });\n    }\n\n    var state = {\n      ladyLuck: Math.floor(Math.random() * 2),\n      containerWidth: containerWidth,\n      containerHeight: containerHeight,\n      imagesToShow: imagesToShow\n    };\n\n    if (_this.props.containerWidth) {\n      state.containerWidth = _this.props.containerWidth;\n    }\n\n    _this.state = state;\n    return _this;\n  }\n\n  var _proto = ReactPhotoGrid.prototype;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    var _this2 = this;\n\n    imageElements.forEach(function (imageElement) {\n      imageElement.removeEventListener(\"load\", imageLoadCallback(imageElement.id, _this2.recalculateGrid));\n    });\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this3 = this;\n\n    this.state.imagesToShow.forEach(function (image) {\n      getImageDimensions(image.src, image.id, _this3.recalculateGrid);\n    }, this); // only set it to parents width/height if no gridsize is provided\n\n    if (!this.props.gridSize && this.containerRef && this.containerRef.current) {\n      this.setState({\n        containerWidth: this.containerRef.current.offsetWidth,\n        containerHeight: this.containerRef.current.offsetWidth\n      });\n    } // $(ReactDOM.findDOMNode(this)..resize(this.onResize);\n    // elementResizeEvent(ReactDOM.findDOMNode(this). this.onResize);\n\n  };\n\n  _proto.render = function render() {\n    var _this4 = this;\n\n    var componentStyles = this.getComponentStyles(this.state.imagesToShow);\n    var images = this.state.imagesToShow.map(function (image, index) {\n      var componentStyle = componentStyles[index]; // max width and height has to be dynamic depending on this image's dimensions\n\n      var imageStyle;\n\n      if (image.width && image.height && componentStyle.width && componentStyle.height) {\n        if (image.width <= componentStyle.width || image.height <= componentStyle.height) ;else if (image.width / componentStyle.width < image.height / componentStyle.height) {\n          imageStyle = {\n            maxWidth: componentStyle.width\n          };\n        } else {\n          imageStyle = {\n            maxHeight: componentStyle.height\n          };\n        }\n      }\n\n      return createElement(\"div\", {\n        key: \"image_\" + index,\n        style: componentStyle\n      }, createElement(\"img\", {\n        style: imageStyle,\n        src: image.src,\n        onClick: function onClick() {\n          return _this4.handleImageClick(image.src);\n        }\n      }));\n    }, this);\n    var containerStyle = {\n      width: this.state.containerWidth,\n      height: this.state.containerWidth,\n      backgroundColor: \"white\"\n    }; // the outer div is needed so that container width can be recalculated based on the parent container width (which the outer div inherits\n    // the div inside the outer div is assigned a width in the first render itself. so that doesn't work out while trying to reset container width\n\n    return createElement(\"div\", null, createElement(\"div\", {\n      style: containerStyle\n    }, images, createElement(\"div\", {\n      style: {\n        clear: \"both\"\n      }\n    })));\n  };\n\n  return ReactPhotoGrid;\n}(Component);\n\nexport default ReactPhotoGrid;","map":{"version":3,"sources":["../src/ReactPhotoGrid.tsx"],"names":["imageElements","callback","img","imageLoadCallback","arr","item","acc","pred","iteratee","ReactPhotoGrid","React","defaultContainerWidth","defaultContainerHeight","containerWidth","containerHeight","container","parseInt","imageData","isString","imagesToShow","id","Math","src","width","height","image","state","ladyLuck","componentWillUnmount","imageElement","componentDidMount","getImageDimensions","offsetWidth","_imagesToShow","imageIndex","findIndex","indexForMaxDimensionImage","contenders","winner","loser","first","without","all","maxDimensionImage","max","indexForBestMaxImage","numberOfImages","images","marginSetters","marginWinner","marginLoser","smallestDimensionRaw","margin","smallImageDimension","styles","commonStyle","display","position","overflow","float","verticalAlign","cursor","styleForSmallerImages","i","render","componentStyles","componentStyle","imageStyle","maxWidth","maxHeight","key","index","style","onClick","containerStyle","backgroundColor","clear"],"mappings":"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","sourcesContent":["import * as React from \"react\";\n\n// TODO - element resize event is not working\nvar imageElements: Array<HTMLImageElement> = [];\n\nfunction imageLoadCallback(\n  id: string,\n  callback: (id: string, width: number, height: number) => void\n) {\n  return function (this: HTMLImageElement) {\n    callback(id, this.naturalWidth, this.naturalHeight);\n  };\n}\n\nfunction getImageDimensions(\n  src: string,\n  id: string,\n  cb: (id: string, width: number, height: number) => void\n) {\n  var img = new Image();\n  img.id = id;\n  imageElements.push(img);\n  img.addEventListener(\"load\", imageLoadCallback(id, cb));\n\n  img.src = src;\n}\n\nfunction isString(str: unknown) {\n  return typeof str === \"string\";\n}\n\nfunction first<T>(arr: Array<T>): T {\n  return arr[0];\n}\n\nfunction without<T>(arr: Array<T>, exclude: T): Array<T> {\n  return arr.filter((item) => item !== exclude);\n}\n\nfunction findIndex<T>(arr: Array<T>, pred: (val: T) => boolean): number {\n  return arr.reduce((acc, val, index) => {\n    if (acc >= 0) {\n      return acc;\n    }\n\n    return pred(val) ? index : acc;\n  }, -1);\n}\n\nfunction all<T>(arr: Array<T>, pred: (val: T) => boolean): boolean {\n  return arr.reduce((acc: boolean, item: T) => {\n    return pred(item) && acc;\n  }, true);\n}\n\nfunction max<T>(arr: Array<T>, iteratee: (arg0: T) => number) {\n  return arr.reduce((acc, item) => {\n    if (iteratee(item) > iteratee(acc)) {\n      return item;\n    } else {\n      return acc;\n    }\n  }, arr[0]);\n}\n\ninterface ImageData {\n  id: string;\n  src: string;\n}\n\ntype StateImageData = ImageData & {\n  width: number;\n  height: number;\n};\n\ninterface Props {\n  data: Array<string> | Array<ImageData>;\n  onImageClick: (image: string) => void;\n  gridSize?: string;\n  containerWidth?: number;\n}\n\ninterface State {\n  ladyLuck: number;\n  containerWidth: number;\n  containerHeight: number;\n  imagesToShow: Array<StateImageData>;\n}\n\nclass ReactPhotoGrid extends React.Component<Props, State> {\n  private containerRef = React.createRef<HTMLDivElement>();\n\n  constructor(props: Props) {\n    super(props);\n\n    const defaultContainerWidth = 500;\n    const defaultContainerHeight = 500;\n\n    let containerWidth = defaultContainerWidth;\n    let containerHeight = defaultContainerHeight;\n\n    if (this.props.gridSize) {\n      var container = this.props.gridSize.split(\"x\");\n      containerWidth = parseInt(container[0], 10) || defaultContainerWidth;\n      containerHeight = parseInt(container[1], 10) || defaultContainerHeight;\n    }\n\n    const imageData =\n      this.props.data.length <= 4\n        ? this.props.data\n        : this.props.data.slice(0, 4);\n    let imagesToShow;\n\n    // take care of variations in property data\n    // if someone just passes an array of path strings\n    if (imageData[0] && isString(imageData[0])) {\n      imagesToShow = (imageData as Array<string>).map(function (\n        imagePath: string\n      ) {\n        return {\n          id: `${Math.random() * 1000}`,\n          src: imagePath,\n          width: 0,\n          height: 0,\n        };\n      });\n    } else {\n      imagesToShow = (imageData as Array<ImageData>).map(function (\n        image: ImageData\n      ) {\n        return {\n          id: image.id || `${Math.random() * 1000}`,\n          src: image.src, // in case someone supplies a src property instead of path\n          ...image,\n          width: 0,\n          height: 0,\n        };\n      });\n    }\n\n    var state = {\n      ladyLuck: Math.floor(Math.random() * 2),\n      containerWidth: containerWidth,\n      containerHeight: containerHeight,\n      imagesToShow,\n    };\n\n    if (this.props.containerWidth) {\n      state.containerWidth = this.props.containerWidth;\n    }\n\n    this.state = state;\n  }\n\n  componentWillUnmount() {\n    imageElements.forEach((imageElement) => {\n      imageElement.removeEventListener(\n        \"load\",\n        imageLoadCallback(imageElement.id, this.recalculateGrid)\n      );\n    });\n  }\n\n  componentDidMount() {\n    this.state.imagesToShow.forEach((image: StateImageData) => {\n      getImageDimensions(image.src, image.id, this.recalculateGrid);\n    }, this);\n\n    // only set it to parents width/height if no gridsize is provided\n    if (\n      !this.props.gridSize &&\n      this.containerRef &&\n      this.containerRef.current\n    ) {\n      this.setState({\n        containerWidth: this.containerRef.current.offsetWidth,\n        containerHeight: this.containerRef.current.offsetWidth,\n      });\n    }\n\n    // $(ReactDOM.findDOMNode(this)..resize(this.onResize);\n    // elementResizeEvent(ReactDOM.findDOMNode(this). this.onResize);\n  }\n\n  // Throttle updates to 60 FPS.\n  onResize = () => {\n    if (this.containerRef && this.containerRef.current) {\n      this.setState({\n        containerWidth: this.containerRef.current.offsetWidth,\n        containerHeight: this.containerRef.current.offsetWidth,\n      });\n    }\n  };\n\n  handleImageClick = (imageSrc: string) => {\n    this.props.onImageClick && this.props.onImageClick(imageSrc);\n  };\n\n  recalculateGrid = (id: string, width: number, height: number) => {\n    var _imagesToShow = [...this.state.imagesToShow];\n\n    var imageIndex = findIndex(_imagesToShow, (image) => image.id === id);\n    _imagesToShow[imageIndex].width = width;\n    _imagesToShow[imageIndex].height = height;\n    var indexForMaxDimensionImage = 0;\n    var container = {\n      width: this.state.containerWidth,\n      height: this.state.containerHeight,\n    };\n\n    var contenders = [\"Width\", \"Height\"];\n    var winner = contenders[this.state.ladyLuck].toLowerCase() as\n      | \"width\"\n      | \"height\";\n    var loser = first(\n      without(contenders, contenders[this.state.ladyLuck])\n    ).toLowerCase() as \"width\" | \"height\";\n\n    // if all the images have width and height, we can rotate the array around the image with max height,\n    // so that the first image has the max height and can be displayed properly on the left side\n    if (\n      all(_imagesToShow, (image: StateImageData) => {\n        return !!(image.width && image.height);\n      })\n    ) {\n      // TODO - the logic should not only look the the image with max height but with height >= containerHeight and max(height/width ratio)\n\n      var maxDimensionImage = max(_imagesToShow, (image) => image[winner]);\n\n      indexForMaxDimensionImage = findIndex(\n        _imagesToShow,\n        (image) => image.id === maxDimensionImage.id\n      );\n\n      if (\n        _imagesToShow[indexForMaxDimensionImage][winner] < container[winner]\n      ) {\n        container[winner] = _imagesToShow[indexForMaxDimensionImage][winner];\n        container[loser] = container[winner];\n      }\n\n      var indexForBestMaxImage = _imagesToShow.reduce(function (\n        result,\n        image,\n        index\n      ) {\n        if (\n          image[winner] >= container[winner] &&\n          image[winner] / image[loser] >\n            _imagesToShow[result][winner] / _imagesToShow[result][loser]\n        ) {\n          return index;\n        }\n        return result;\n      },\n      0);\n\n      _imagesToShow.push.apply(\n        _imagesToShow,\n        _imagesToShow.splice(0, indexForBestMaxImage)\n      );\n      this.setState({\n        imagesToShow: _imagesToShow,\n        containerHeight: container.height,\n        containerWidth: container.width,\n      });\n    }\n  };\n\n  getComponentStyles = (images: Array<StateImageData>) => {\n    var numberOfImages = images.length;\n\n    var marginSetters = [\"Bottom\", \"Right\"];\n    var contenders = [\"Width\", \"Height\"];\n    var winner = contenders[this.state.ladyLuck] as \"Width\" | \"Height\";\n    var loser = first(without(contenders, winner));\n    var marginWinner = marginSetters[this.state.ladyLuck];\n    var marginLoser = first(without(marginSetters, marginWinner));\n\n    var smallestDimensionRaw = Math.floor(\n      this.state[`container${winner}` as \"containerWidth\"] /\n        (numberOfImages - 1)\n    );\n    var margin = 2;\n    var smallImageDimension = smallestDimensionRaw - margin;\n    var styles: Array<any> = [];\n    var commonStyle = {\n      display: \"inline-block\",\n      position: \"relative\",\n      overflow: \"hidden\",\n      float: \"left\",\n      verticalAlign: \"top\",\n      cursor: \"pointer\",\n    };\n\n    switch (numberOfImages) {\n      case 0:\n        break;\n      case 1:\n        // set some big numbers in case width and height not provided\n        if (!images[0].width) images[0].width = 1000000;\n        if (!images[0].height) images[0].height = 1000000;\n\n        if (images[0].width > images[0].height) {\n          styles = [\n            {\n              width:\n                Math.min(this.state.containerWidth, images[0].width) - margin,\n              height:\n                (Math.min(this.state.containerWidth, images[0].width) *\n                  images[0].height) /\n                  images[0].width -\n                margin,\n              margin: margin,\n            },\n          ];\n        } else {\n          styles = [\n            {\n              width:\n                (Math.min(this.state.containerHeight, images[0].height) *\n                  images[0].width) /\n                  images[0].height -\n                margin,\n              height:\n                Math.min(this.state.containerHeight, images[0].height) - margin,\n              margin: margin,\n            },\n          ];\n        }\n        break;\n      case 2:\n        styles[0] = styles[1] = {};\n\n        styles[0][winner.toLowerCase() as \"width\" | \"height\"] = styles[1][\n          winner.toLowerCase() as \"width\" | \"height\"\n        ] =\n          this.state[\n            `container${winner}` as \"containerWidth\" | \"containerHeight\"\n          ] - margin;\n        styles[0][loser.toLowerCase()] = styles[1][loser.toLowerCase()] =\n          Math.min(smallImageDimension / 2) - margin;\n        styles[0][\"margin\" + marginWinner] = margin;\n        break;\n      default:\n        styles[0] = {};\n        styles[0][winner.toLowerCase()] = this.state[\n          `container${winner}` as \"containerWidth\" | \"containerHeight\"\n        ];\n        styles[0][loser.toLowerCase()] =\n          smallImageDimension * (numberOfImages - 2);\n        styles[0][\"margin\" + marginWinner] = margin;\n        var styleForSmallerImages: any = {\n          width: smallImageDimension,\n          height: smallImageDimension,\n        };\n        styleForSmallerImages[\"margin\" + marginLoser] = margin;\n\n        for (var i = 1; i < numberOfImages && i < 4; i++) {\n          // cloning is important here because otherwise changing the dimension of last image changes it for everyone\n          styles.push({ ...styleForSmallerImages });\n        }\n\n        // adjust the width/height of the last image in case of round off errors in division\n        styles[numberOfImages - 1][winner.toLowerCase()] +=\n          styles[0][winner.toLowerCase()] -\n          smallImageDimension * (numberOfImages - 1) -\n          margin * (numberOfImages - 2);\n        styles[numberOfImages - 1][\"margin\" + marginLoser] = 0;\n    }\n\n    return styles.map(function (style) {\n      return {\n        ...commonStyle,\n        ...style,\n      };\n    });\n  };\n\n  render() {\n    var componentStyles = this.getComponentStyles(this.state.imagesToShow);\n\n    var images = this.state.imagesToShow.map((image, index) => {\n      var componentStyle = componentStyles[index];\n\n      // max width and height has to be dynamic depending on this image's dimensions\n      var imageStyle;\n\n      if (\n        image.width &&\n        image.height &&\n        componentStyle.width &&\n        componentStyle.height\n      ) {\n        if (\n          image.width <= componentStyle.width ||\n          image.height <= componentStyle.height\n        ) {\n          // do nothing\n        } else if (\n          image.width / componentStyle.width <\n          image.height / componentStyle.height\n        ) {\n          imageStyle = {\n            maxWidth: componentStyle.width,\n          };\n        } else {\n          imageStyle = {\n            maxHeight: componentStyle.height,\n          };\n        }\n      }\n\n      return (\n        <div key={\"image_\" + index} style={componentStyle}>\n          <img\n            style={imageStyle}\n            src={image.src}\n            onClick={() => this.handleImageClick(image.src)}\n          />\n        </div>\n      );\n    }, this);\n\n    var containerStyle = {\n      width: this.state.containerWidth,\n      height: this.state.containerWidth,\n      backgroundColor: \"white\",\n    };\n    // the outer div is needed so that container width can be recalculated based on the parent container width (which the outer div inherits\n    // the div inside the outer div is assigned a width in the first render itself. so that doesn't work out while trying to reset container width\n    return (\n      <div>\n        <div style={containerStyle}>\n          {images}\n          <div style={{ clear: \"both\" }} />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default ReactPhotoGrid;\n"]},"metadata":{},"sourceType":"module"}